# 백트래킹 (Backtracking)

**백트래킹(Backtracking)**은 **결정 문제**를 해결하는 방법 중 하나로, 모든 가능한 후보 해를 탐색하며 **해당 경로가 유망한지 여부**를 체크하면서 진행하는 알고리즘 기법입니다. 만약 유망하지 않은 경로라고 판단되면, 해당 경로는 더 이상 탐색하지 않고 **되돌아가서** 다른 경로를 탐색하는 방식으로 문제를 해결합니다.

## 백트래킹의 기본 개념

백트래킹은 **재귀적으로 문제를 해결**하는 방식으로, 트리 구조의 해를 하나씩 선택하면서, 유효하지 않은 경로가 발견되면 **백트랙(backtrack)**하여 다시 이전 선택으로 돌아가는 것이 핵심입니다. 즉, 다음과 같은 순서로 동작합니다:

1. 해를 찾기 위해서 **트리의 한 경로**를 선택합니다.
2. 그 경로가 **해가 될 가능성이 있는지** 검사합니다.
3. 가능성이 없다면 그 경로에서 **되돌아갑니다**.
4. 가능성이 있다면 다음 선택으로 넘어가며, 해를 찾을 때까지 계속합니다.

## 백트래킹을 사용할 수 있는 문제

백트래킹은 **완전 탐색**을 기반으로 하며, 다음과 같은 문제에 적합합니다:

- **N-Queen 문제**: N x N 체스판에 N개의 퀸을 서로 공격하지 않도록 배치하는 문제.
- **미로 찾기**: 미로의 시작점에서 끝점까지 도달하는 경로를 찾는 문제.
- **Subset Sum 문제**: 주어진 집합에서 특정 합을 가지는 부분 집합을 찾는 문제.
- **Knapsack 문제**: 주어진 물건들을 배낭에 넣을 때, 배낭의 무게 제한을 넘기지 않으면서 최대 가치를 얻는 문제.
- **순열, 조합 문제**: 특정 조건을 만족하는 모든 순열 또는 조합을 찾는 문제.

## 백트래킹의 장단점

- **장점**: 
  - **효율적**: 가능한 해가 유망하지 않다고 판단되면 더 이상 그 경로를 탐색하지 않기 때문에, 불필요한 계산을 줄일 수 있습니다.
  
- **단점**: 
  - 경우에 따라 **시간 복잡도**가 높을 수 있습니다. (완전 탐색의 특성상, 최악의 경우에는 모든 경로를 탐색해야 함)

## 백트래킹 문제 해결 과정

백트래킹을 통한 문제 해결 과정은 다음과 같습니다:

1. **경로 선택**: 문제의 가능한 해의 경로를 선택합니다.
2. **유망성 검사**: 선택한 경로가 유망한지 검사합니다.
3. **해가 아닌 경우**: 유망하지 않은 경로는 더 이상 탐색하지 않고 되돌아갑니다.
4. **유망한 경우**: 다음 단계로 넘어가서 경로를 선택하고 다시 유망성 검사를 수행합니다.
5. **해 도달 시 종료**: 가능한 해가 발견되면 탐색을 종료합니다.

## 백트래킹을 사용한 N-Queen 문제 예제 (C#)

### N-Queen 문제란?
N x N 크기의 체스판 위에 N개의 퀸을 서로 공격하지 않도록 배치하는 문제입니다. 퀸은 가로, 세로, 대각선으로 움직일 수 있기 때문에 서로의 경로에 위치하지 않아야 합니다.

### C# 예제 코드 (N-Queen 문제)

```csharp
using System;

class NQueen
{
    private static int N;
    private static int[] board;

    public static void Main()
    {
        N = 8; // 예: 8-퀸 문제
        board = new int[N];
        Solve(0);
    }

    private static void Solve(int row)
    {
        if (row == N)
        {
            PrintBoard();
            return;
        }

        for (int col = 0; col < N; col++)
        {
            if (IsSafe(row, col))
            {
                board[row] = col; // 퀸을 배치
                Solve(row + 1); // 다음 행으로 재귀 호출
            }
        }
    }

    private static bool IsSafe(int row, int col)
    {
        for (int i = 0; i < row; i++)
        {
            // 동일한 열에 있거나, 대각선 상에 있는지 검사
            if (board[i] == col || Math.Abs(board[i] - col) == Math.Abs(i - row))
                return false;
        }
        return true;
    }

    private static void PrintBoard()
    {
        Console.WriteLine("Solution:");
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < N; j++)
            {
                if (board[i] == j)
                    Console.Write("Q ");
                else
                    Console.Write(". ");
            }
            Console.WriteLine();
        }
        Console.WriteLine();
    }
}
```

### 설명
- **IsSafe** 함수는 현재 행에 퀸을 놓을 수 있는지를 검사합니다. 같은 열에 이미 퀸이 있는지, 또는 대각선 상에 퀸이 있는지를 확인합니다.
- **Solve** 함수는 현재 행에 가능한 모든 열에 퀸을 놓아보고, 놓을 수 있다면 다음 행으로 넘어가 재귀적으로 문제를 해결합니다.
- 퀸을 모두 배치하면 **PrintBoard** 함수를 통해 퀸이 배치된 체스판을 출력합니다.

## 백트래킹의 응용

- **퍼즐 해결**: 스도쿠, 퍼즐 등의 해결에서 사용됩니다.
- **경로 탐색**: 미로 탐색, 그래프에서 경로 찾기 등에 적용됩니다.
- **문자열 문제**: 순열 생성, 문자열 매칭 등에서도 백트래킹이 유용합니다.

## 백트래킹과 다른 알고리즘 비교

- **브루트포스 (Brute Force)**: 백트래킹은 브루트포스 탐색의 최적화된 형태로, 모든 경로를 탐색하는 대신 유망하지 않은 경로는 배제합니다.
- **동적 계획법 (Dynamic Programming)**: 백트래킹은 **결과를 저장하지 않고** 유망한 경로만 탐색하는 반면, 동적 계획법은 **부분 문제의 결과를 저장**하여 동일한 문제를 여러 번 풀지 않도록 합니다.

백트래킹은 **탐색 공간을 줄이면서도 완전한 해를 찾는** 유용한 방법으로, 다양한 문제에서 적용됩니다.

### 참조 링크
* [백트래킹 위키피디아](https://ko.wikipedia.org/wiki/%ED%87%B4%EA%B0%81%EA%B2%80%EC%83%89)
